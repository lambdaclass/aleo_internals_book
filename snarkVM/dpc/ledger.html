<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ledger - Aleo Book</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../../introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../../snarkVM/snarkVM.html"><strong aria-hidden="true">2.</strong> snarkVM</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../snarkVM/dpc/dpc.html"><strong aria-hidden="true">2.1.</strong> dpc</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../snarkVM/dpc/ledger.html" class="active"><strong aria-hidden="true">2.1.1.</strong> ledger</a></li><li class="chapter-item expanded "><a href="../../snarkVM/dpc/account.html"><strong aria-hidden="true">2.1.2.</strong> account</a></li></ol></li><li class="chapter-item expanded "><a href="../../snarkVM/virtual_machine/introduction.html"><strong aria-hidden="true">2.2.</strong> virtual_machine</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../snarkVM/virtual_machine/execution.html"><strong aria-hidden="true">2.2.1.</strong> execution</a></li><li class="chapter-item expanded "><a href="../../snarkVM/virtual_machine/input_circuit.html"><strong aria-hidden="true">2.2.2.</strong> input_circuit</a></li><li class="chapter-item expanded "><a href="../../snarkVM/virtual_machine/virtual_machine.html"><strong aria-hidden="true">2.2.3.</strong> vritual_machine</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../../snarkOS/snarkOS.html"><strong aria-hidden="true">3.</strong> snarkOS</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Aleo Book</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h6 id="tags-snarkvm_exploration"><a class="header" href="#tags-snarkvm_exploration">tags: <code>snarkVM_exploration</code></a></h6>
<h1 id="dpcledger"><a class="header" href="#dpcledger">dpc::Ledger</a></h1>
<p>Reexports</p>
<ul>
<li>blocks</li>
<li>ledger</li>
<li>ledger_proof</li>
<li>ledger_tree</li>
<li>local_proof</li>
<li>memory_pool</li>
<li>record_proof</li>
<li>transitions</li>
</ul>
<h2 id="ledger"><a class="header" href="#ledger">ledger</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Ledger&lt;N: Network&gt; {
    /// The canonical chain of blocks.
    canon_blocks: Blocks&lt;N&gt;,
    /// The set of unknown orphan blocks.
    orphan_blocks: HashMap&lt;u32, Block&lt;N&gt;&gt;,
    /// The pool of unconfirmed transactions.
    memory_pool: MemoryPool&lt;N&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>Ledger</code> keeps track of the canonical chain (current chain), the orphan blocks (yet to be confirmed) and the unconfirmed transactions.</p>
<p>After a few getters we then get to the interesting stuff, which is actually altering state. <code>add_next_block</code>, <code>to_ledger_proof</code> and <code>to_ledger_tree</code> immediately call the respective method of canon_blocks, so we'll handle that later when we talk about <code>Blocks</code>. </p>
<p><code>add_orphan_block</code> is pretty straightforward, it suffices to know that it checks that the block is in fact orphan (not present in the canonical chain).
<strong>question</strong>: documentation says <code>/// Adds the given orphan block, if it is well-formed and does not already exist.</code> but it never validates the well-formedness of the block, is that missing or are <code>Block&lt;N&gt;</code> validated before constructing?</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Adds the given unconfirmed transaction to the memory pool.
pub fn add_unconfirmed_transaction(&amp;mut self, transaction: &amp;Transaction&lt;N&gt;) -&gt; Result&lt;()&gt; {
    ensure!(
        self.canon_blocks.contains_ledger_root(&amp;transaction.ledger_root()), 
        &quot;Transaction references a non-existent ledger root&quot;
    );

    // Ensure the transaction does not contain serial numbers already in the canon chain.
    for serial_number in transaction.serial_numbers() {
        ensure!(
            !self.canon_blocks.contains_serial_number(serial_number), 
            &quot;Transaction contains a serial number already in existence&quot;
        );
    }

    // Ensure the transaction does not contain commitments already in the canon chain.
    for commitment in transaction.commitments() {
        ensure!(
            !self.canon_blocks.contains_commitment(commitment), 
            &quot;Transaction contains a commitment already in existence&quot;
        );
    }
    // Attempt to add the transaction into the memory pool.
    self.memory_pool.add_transaction(transaction)?;

    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>A transaction needs to reference the canonical chain's root, and all of its serial numbers and it's commitment need to be unused in the canonical chain to be included in the transaction memory pool.</p>
<p>The juciest function is <code>mine_next_block</code> which performs the following steps:</p>
<ul>
<li>Ensure that the new timestamp is ahead of the previous timestamp (it's more of a fix it if it is not ahead, it won't throw an error if it is behind).</li>
<li>Compute the block difficulty (currently uses the height as well as some of the genesis_block parameters)</li>
<li>Compute the cumulative weight $\sum_{b \in \text{canonical_chain}} u64_{\text{max}} / \text{difficulty}_b$ including the candidate block.</li>
<li>Construct the new block transactions. Build coinbase and block transactions containing the coinbase and the mempool transactions (there's a <code>VirtualMaching::execute</code> call behind the scenes)</li>
<li>Construct the block template.</li>
<li>Mine the next block.</li>
<li>Attempt to add the block to the canon chain.</li>
<li>On <strong>success</strong>, clear the memory pool of its transactions.</li>
</ul>
<h2 id="blocks"><a class="header" href="#blocks">Blocks</a></h2>
<p>The Blocks struct represents a chain of blocks and is used in the ledger to store the canonical chain of blocks</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Blocks&lt;N: Network&gt; {
    /// The current block height.
    current_height: u32,
    /// The current block hash.
    current_hash: N::BlockHash,
    /// The current ledger tree.
    ledger_tree: LedgerTree&lt;N&gt;,
    /// The chain of previous block hashes.
    previous_hashes: HashMap&lt;u32, N::BlockHash&gt;,
    /// The chain of block headers.
    headers: HashMap&lt;u32, BlockHeader&lt;N&gt;&gt;,
    /// The chain of block transactions.
    transactions: HashMap&lt;u32, Transactions&lt;N&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>Most functions in <code>blocks.rs</code> are getters/setters that delegate the responsibility to either the <code>ledger_tree</code>, <code>previous_hashes</code>, <code>headers</code>, or <code>transactions</code>.</p>
<p>One of the 'heavy' functions is <code>add_next</code>, which adds a block as the latest in the canonical chain and is used by the <code>Ledger</code>. 
It runs some verifications by ensuring:</p>
<ul>
<li>The given block is valid</li>
<li>The given block has the correct block height</li>
<li>The given block height does not already exist in the ledger</li>
<li>The given block has the appropiate previous block hash</li>
<li>The given block hash does not already exist in the ledger</li>
<li>The next block timestamp is within the declared time limit</li>
<li>The given block timestamp is after the current timestamp</li>
<li>The given block difficulty target is correct</li>
<li>The expected cumulative weight is computed correctly</li>
<li>The given cumulative weight is correct.</li>
<li>Each transaction in the block does not already exist in the ledger</li>
<li>Each transaction's ledger root is the same as the ledger's</li>
<li>Each serial number does not exist in the ledger</li>
<li>Each commitment does not exist in the ledger</li>
</ul>
<p>And after that it attempts to add the block in each structure.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Add the block to the ledger. This code section executes atomically.
{
    let mut blocks = self.clone();

    blocks.current_height = height;
    blocks.current_hash = block_hash;
    blocks.ledger_tree.add(&amp;block.hash())?;
    blocks.previous_hashes.insert(height, block.previous_block_hash());
    blocks.headers.insert(height, block.header().clone());
    blocks.transactions.insert(height, block.transactions().clone());

    *self = blocks;
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>question</strong>: why does this execute atomically? Did they actually meant that since the self is cloned you don't have race conditions? because the block does not execute atomically. 
Is it possible to add two different blocks with the same height twice? -&gt; No, since each <code>add_next</code> call overwrites the whole structure</p>
<p>The next function to take a look at is the to_ledger_proof. This does a bunch of things but succintly, it computes a few other proofs:</p>
<pre><code class="language-mermaid">flowchart LR

a[LedgerProof] --&gt; b[LedgerRootInclusionProof]
a[LedgerProof] --&gt; c[RecordProof]

c[RecordProof] --&gt; d[BlockHeaderInclusionProof]
c[RecordProof] --&gt; e[TransactionsInclusionProof]
c[RecordProof] --&gt; f[LocalInclusionProof]

d[BlockHeaderInclusionProof] --&gt; g[BlockHeader::to_header_inclusion_proof]
e[TransactionsInclusionProof] --&gt; h[Transactions::to_transactions_inclusion_proof]
f[LocalInclusionProof] --&gt; i[Transitions::to_local_proof]
b[LedgerRootInclusionProof] --&gt; j[LedgerTree::to_ledger_inclusion_proof]

i[Transitions::to_local_proof] --&gt; k[Transition::to_transition_inclusion_proof]
i[Transitions::to_local_proof] --&gt; l[Transitions::to_transition_inclusion_proof]

</code></pre>
<p>The last function is <code>assert_retarget</code>, which is used to compute the difficulty of the next block to be mined, and is based on the difficulty retarget algorithm from the <a href="https://www.reference.cash/protocol/forks/2020-11-15-asert">zcash protocol</a>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>///     T_{i+1} = T_anchor * 2^((S - B * N) / tau).
///     T_anchor = Anchor target of a specific block height
///     B = Expected time per block.
///     S = Time elapsed since the anchor.
///     N = Number of blocks since the anchor.
///     tau = The half life of the algorithm. For every `tau` seconds ahead of
///           schedule a block’s timestamp becomes, the difficulty doubles.
/// To avoid use of floating points, we use fixed-point arithmetic.
<span class="boring">}
</span></code></pre></pre>
<h2 id="ledgertree"><a class="header" href="#ledgertree">LedgerTree</a></h2>
<p>The ledger tree is a merkle tree</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct LedgerTree&lt;N: Network&gt; {
    #[derivative(Debug = &quot;ignore&quot;)]
    tree: Arc&lt;MerkleTree&lt;N::LedgerRootParameters&gt;&gt;,
    block_hashes: HashMap&lt;N::BlockHash, u32&gt;,
    current_index: u32,
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>tree</code> is the actual Merkle Tree, but the <code>block_hashes</code> are used to keep track of the blocks in the tree (lookup is faster) and to map the block hash to its respective height in the tree. The <code>current index keeps track of the index of the last added block in the tree</code></p>
<p>There are two methods for adding blocks, <code>add</code> and <code>add_all</code>. Those are pretty much well documented. One thing i noticed is this piece:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> self.tree = match self.current_index {
        0 =&gt; Arc::new(MerkleTree::&lt;N::LedgerRootParameters&gt;::new::&lt;N::BlockHash&gt;(
            Arc::new(N::ledger_root_parameters().clone()),
            block_hashes,
        )?),
        _ =&gt; Arc::new(self.tree.rebuild(self.current_index as usize, block_hashes)?),
};
<span class="boring">}
</span></code></pre></pre>
<p><strong>question</strong>: why would you handle things differently?</p>
<p><strong>question2</strong>: why do we do this twice?</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ensure!(
        (self.current_index as usize).saturating_add(num_block_hashes) &lt;= u32::MAX as usize, 
        &quot;The ledger tree will reach its maximum size.&quot;
    );
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>self.current_index = self
        .current_index
        .checked_add(num_block_hashes as u32)
        .ok_or_else(|| anyhow!(&quot;The index exceeds the maximum number of allowed block hashes.&quot;))?;
    let end_index = self.current_index.checked_sub(1).ok_or_else(|| anyhow!(&quot;Integer underflow.&quot;))?;
<span class="boring">}
</span></code></pre></pre>
<p>The rest of the methods are getters and setters, the <code>MerkleTree</code> takes care of the inclusion proof:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Returns the Merkle path for a given block hash.
fn to_ledger_inclusion_proof(&amp;self, block_hash: &amp;N::BlockHash) -&gt; Result&lt;MerklePath&lt;N::LedgerRootParameters&gt;&gt; {
    match self.get_block_hash_index(block_hash) {
        Some(index) =&gt; Ok(self.tree.generate_proof(*index as usize, block_hash)?),
        _ =&gt; Err(MerkleError::MissingLeaf(format!(&quot;{}&quot;, block_hash)).into()),
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="transitions"><a class="header" href="#transitions">Transitions</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub(crate) struct Transitions&lt;N: Network&gt; {
    #[derivative(Debug = &quot;ignore&quot;)]
    tree: Arc&lt;MerkleTree&lt;N::TransactionIDParameters&gt;&gt;,
    transitions: HashMap&lt;N::TransitionID, (u8, Transition&lt;N&gt;)&gt;,
    current_index: u8,
}
<span class="boring">}
</span></code></pre></pre>
<p>As the LedgerTree, this is also a wrapper of a Merkle Tree used for storing a set of Transitions.</p>
<p>IN FACT, <strong>question</strong>: Is this abstractable?</p>
<p>The method that differs a bit is the <code>to_local_proof</code> one, which gets the corresponding transition for the commitment, and makes an inclusion proof of the commitment in the transition and the transition in the transition tree.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> /// Returns the local proof for a given commitment.
    pub(crate) fn to_local_proof(&amp;self, commitment: N::Commitment) -&gt; Result&lt;LocalProof&lt;N&gt;&gt; {
        let (_, (_, transition)) = match self
            .transitions
            .iter()
            .filter(|(_, (_, transition))| transition.contains_commitment(&amp;commitment))
            .last()
        {
            Some(tuple) =&gt; tuple,
            None =&gt; return Err(MerkleError::MissingLeaf(format!(&quot;{}&quot;, commitment)).into()),
        };

        let transition_id = transition.transition_id();
        let transition_inclusion_proof = transition.to_transition_inclusion_proof(commitment)?;
        let transaction_id = self.root();
        let transaction_inclusion_proof = self.to_transition_path(transition_id)?;

        LocalProof::new(
            transaction_id,
            transaction_inclusion_proof,
            transition_id,
            transition_inclusion_proof,
            commitment,
        )
    }
<span class="boring">}
</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../snarkVM/dpc/dpc.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../../snarkVM/dpc/account.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../snarkVM/dpc/dpc.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../../snarkVM/dpc/account.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../../mermaid.min.js"></script>
        <script type="text/javascript" src="../../mermaid-init.js"></script>
    </body>
</html>
